# Milestone 7 — Recording Mode Integration

## Overview

This milestone wires `StepRecorder` (M6) into `ReportBugDialog` (M5) to deliver the
complete "Record Steps" user flow:

1. User clicks **Start Recording** in the dialog.
2. Application captures a `SessionState` baseline snapshot of the current state.
3. A small floating **● Recording Steps** indicator appears.
4. `StepRecorder` begins hooking into existing application signals.
5. User reproduces the bug naturally.
6. User clicks **Stop Recording**.
7. `StepRecorder` disconnects all signals; steps are frozen.
8. User clicks **Generate Report** — the report now includes the baseline snapshot
   and the recorded steps.

Tests in this milestone are added to the existing `tests/gui/test_report_bug_dialog.py`
file and protect behavioral flow only.

---

## Guiding Principles

- **Tests first, implementation second.** Write all tests listed below, confirm every
  one is **failing**, then write the implementation that makes them pass.
- **Zero regression tolerance.** `python run_tests.py` must be fully green at the end
  of this milestone. No existing tests (including M1–M6's) may break.
- **Behavior-focused GUI tests.** Tests verify what the dialog *does* — mode transitions,
  indicator visibility, step presence in report — not widget labels or internal state.
- **Clean resource management.** Closing the dialog while recording is active must stop
  the recorder and disconnect all signals without error or signal leak.
- **Second session replaces first.** Starting, stopping, then starting again must clear
  prior steps before the new session begins.
- **Permanent regression suite.** Every test here is a permanent guard for all future
  milestones and future development.

---

## Goal

Implement:

1. **Recording controls** in `ReportBugDialog` (Start Recording / Stop Recording).
2. **`RecordingIndicator`** — a small floating widget showing `● Recording Steps`.
3. **Signal hook setup** — `StepRecorder.connect_signal()` called for each of the
   application signals listed in the Signal Table below.
4. **Baseline snapshot capture** at the moment recording starts.
5. **Report enrichment** — when Generate is clicked after a recording session, the
   report includes both the baseline state and the recorded steps.

---

## Dependencies

**Requires M5 (completed):** `ReportBugDialog`, `ReportBugDialog` test helper methods,
`MainWindow` with Help menu.

**Requires M6 (completed):** `StepRecorder`, with its connect/disconnect API.

### StepRecorder API Reference (restated for self-containment)

```python
class StepRecorder:
    is_recording: bool  # property

    def start(self) -> None:
        """Activate recording. Guard against double-start (idempotent)."""

    def stop(self) -> tuple[RecordedStep, ...]:
        """Deactivate and disconnect all signals. Return frozen steps snapshot."""

    def clear(self) -> None:
        """Reset steps and seq_num. Does not affect connection state."""

    def record(self, description: str) -> None:
        """Append a step. No-op when inactive."""

    def connect_signal(self, signal, description: str | Callable[..., str]) -> None:
        """Connect a Qt signal to record a step on each emission."""
```

### RecordedStep Reference

```python
@dataclass(frozen=True)
class RecordedStep:
    seq_num: int
    description: str
    timestamp: float
```

### BugReport Reference (sections relevant to this milestone)

```python
@dataclass(frozen=True)
class BugReport:
    description: str
    steps: tuple[RecordedStep, ...] | None = None
    baseline_state: SessionState | None    = None
    # ... other fields
```

---

## New Files

```
pyprobe/gui/recording_indicator.py    create
```

## Modified Files

```
pyprobe/gui/report_bug_dialog.py      add recording controls, baseline capture, signal hooks
tests/gui/test_report_bug_dialog.py   add M7 test cases (appended to existing file)
```

---

## Signals to Hook During Recording

`StepRecorder.connect_signal()` must be called for each of the following during
`_start_recording()`. All sources are accessible from `MainWindow` via the dialog's
injected references or by traversing the parent widget hierarchy.

| Source | Signal | Step Description |
|---|---|---|
| `ProbeController` | `probe_added(anchor, panel)` | `f"Added probe: {anchor.symbol} at line {anchor.line}"` |
| `ProbeController` | `probe_removed(anchor)` | `f"Removed probe: {anchor.symbol} at line {anchor.line}"` |
| `ControlBar` | run button `clicked` | `"Clicked Run"` |
| `ControlBar` | stop button `clicked` | `"Clicked Stop"` |
| Menu actions (View, Help) | `triggered` | `f"Menu: {action.text()}"` |
| `EquationManager` | equation added signal | `f"Added equation: {eq_id}"` |
| `EquationManager` | equation changed signal | `f"Edited equation: {eq_id} = {expr}"` |
| `CodeViewer` | file loaded signal | `f"Loaded file: {sanitized_path}"` |

**Implementation note:** The dialog receives its signals via a `signal_sources` dict
or equivalent injection, not by reaching into `MainWindow` directly. This keeps the
dialog testable without a full `MainWindow`.

---

## `RecordingIndicator` Widget

```python
# pyprobe/gui/recording_indicator.py

class RecordingIndicator(QWidget):
    """Small always-on-top frameless widget showing '● Recording Steps'."""

    def __init__(self, parent=None): ...

    def show_indicator(self) -> None:
        """Make the indicator visible."""

    def hide_indicator(self) -> None:
        """Hide the indicator."""
```

Requirements:
- Frameless, always on top (`Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint`).
- Displays a red dot and text — exact wording is an implementation detail.
- Shown when recording starts, hidden when recording stops or dialog is closed.

---

## Tests to Write First

All tests below are **appended** to `tests/gui/test_report_bug_dialog.py`.
They **must be failing** before any implementation is written.

```python
# ─── MILESTONE 7 ADDITIONS ────────────────────────────────────────────────────
# Appended to tests/gui/test_report_bug_dialog.py


# ── Recording mode state tests ────────────────────────────────────────────────

def test_recording_controls_toggle_state(qtbot):
    """Start Recording becomes unavailable after clicking it, and Stop becomes available.
    After clicking Stop, the reverse is true."""
    dialog = make_dialog(qtbot)

    # Before any recording
    assert dialog._start_recording_action_enabled()
    assert not dialog._stop_recording_action_enabled()

    dialog._trigger_start_recording()

    assert not dialog._start_recording_action_enabled()
    assert dialog._stop_recording_action_enabled()

    dialog._trigger_stop_recording()

    assert dialog._start_recording_action_enabled()
    assert not dialog._stop_recording_action_enabled()


def test_recording_mode_shows_indicator(qtbot):
    """A recording indicator widget is visible after recording starts."""
    dialog = make_dialog(qtbot)
    dialog._trigger_start_recording()
    assert dialog._recording_indicator_visible()


def test_recording_indicator_hidden_after_stop(qtbot):
    """The recording indicator is hidden after recording stops."""
    dialog = make_dialog(qtbot)
    dialog._trigger_start_recording()
    dialog._trigger_stop_recording()
    assert not dialog._recording_indicator_visible()


# ── Report content tests ──────────────────────────────────────────────────────

def test_steps_section_absent_when_no_recording(qtbot):
    """If recording was never started, the generated report contains no steps section."""
    dialog = make_dialog(qtbot)
    dialog._set_description("No recording done.")
    dialog._trigger_generate()
    # Steps were never recorded so no step content should appear
    output = dialog._get_preview_text()
    # The fixture records no steps, so step markers like "1." at line start absent
    lines = [l.strip() for l in output.splitlines()]
    numbered = [l for l in lines if l and l[0].isdigit() and l[1:3] == ". "]
    assert len(numbered) == 0


def test_generated_report_includes_steps_when_recorded(qtbot):
    """Steps section appears in the generated report when at least one step was recorded."""
    dialog = make_dialog(qtbot)
    dialog._trigger_start_recording()
    dialog._inject_step("Manually injected step for testing")
    dialog._trigger_stop_recording()
    dialog._trigger_generate()
    assert "Manually injected step for testing" in dialog._get_preview_text()


def test_generated_report_includes_baseline_state(qtbot):
    """A session state baseline section appears in the report when recording was used."""
    from pyprobe.report.report_model import OpenFileEntry
    collector = SessionStateCollector(
        file_getter=lambda: [
            OpenFileEntry(
                path="/tmp/baseline_demo.py",
                is_probed=True, is_executed=True, has_unsaved=False,
            )
        ],
        probe_getter=lambda: (),
        equation_getter=lambda: (),
        widget_getter=lambda: (),
    )
    dialog = make_dialog(qtbot, collector=collector)
    dialog._trigger_start_recording()
    dialog._trigger_stop_recording()
    dialog._trigger_generate()
    assert "baseline_demo.py" in dialog._get_preview_text()


# ── Signal integration tests ──────────────────────────────────────────────────

def test_step_recorded_when_probe_action_fires(qtbot):
    """Simulating a probe_added signal during recording produces a step in the report."""
    dialog = make_dialog(qtbot)
    dialog._trigger_start_recording()
    dialog._simulate_probe_added("signal_x", line=42)
    dialog._trigger_stop_recording()
    dialog._trigger_generate()
    output = dialog._get_preview_text()
    assert "signal_x" in output or "42" in output


# ── Cleanup and session management tests ─────────────────────────────────────

def test_recording_stops_cleanly_if_dialog_closed(qtbot):
    """Closing the dialog while recording is active stops the recorder without error."""
    dialog = make_dialog(qtbot)
    dialog._trigger_start_recording()
    assert dialog._recorder_is_active()
    dialog.close()  # must not raise
    assert not dialog._recorder_is_active()


def test_generate_after_stop_includes_all_steps(qtbot):
    """All steps accumulated between Start and Stop appear in the generated report."""
    dialog = make_dialog(qtbot)
    dialog._trigger_start_recording()
    dialog._inject_step("Step A")
    dialog._inject_step("Step B")
    dialog._inject_step("Step C")
    dialog._trigger_stop_recording()
    dialog._trigger_generate()
    output = dialog._get_preview_text()
    assert "Step A" in output
    assert "Step B" in output
    assert "Step C" in output


def test_second_recording_session_replaces_first(qtbot):
    """Starting a second recording session clears steps from the first."""
    dialog = make_dialog(qtbot)

    # First session
    dialog._trigger_start_recording()
    dialog._inject_step("First session step")
    dialog._trigger_stop_recording()

    # Second session
    dialog._trigger_start_recording()
    dialog._inject_step("Second session step")
    dialog._trigger_stop_recording()

    dialog._trigger_generate()
    output = dialog._get_preview_text()
    assert "Second session step" in output
    assert "First session step" not in output
```

### Additional Test Helper Methods Required

These test helper methods must be added to `ReportBugDialog`:

| Method | Purpose |
|---|---|
| `_trigger_start_recording()` | Simulates clicking Start Recording |
| `_trigger_stop_recording()` | Simulates clicking Stop Recording |
| `_start_recording_action_enabled() -> bool` | Returns whether Start Recording is available |
| `_stop_recording_action_enabled() -> bool` | Returns whether Stop Recording is available |
| `_recording_indicator_visible() -> bool` | Returns whether the recording indicator is shown |
| `_inject_step(description: str)` | Directly calls `self._recorder.record(description)` |
| `_recorder_is_active() -> bool` | Returns `self._recorder.is_recording` |
| `_simulate_probe_added(symbol: str, line: int)` | Emits a fake probe_added–like event into the recorder |

---

## Implementation Scope

### `pyprobe/gui/report_bug_dialog.py` changes

Add to dialog `__init__`:
```python
self._recorder = StepRecorder()
self._indicator = RecordingIndicator()
self._baseline: SessionState | None = None
self._recorded_steps: tuple[RecordedStep, ...] = ()
```

Add `_start_recording()`:
1. Guard: if `self._recorder.is_recording`, return early (idempotent).
2. Clear the recorder: `self._recorder.clear()`.
3. Capture baseline: `self._baseline = self._collector.collect()`.
4. Connect signals via `self._recorder.connect_signal(...)` for each entry in the
   Signal Table above.
5. Call `self._recorder.start()`.
6. Show the recording indicator: `self._indicator.show_indicator()`.
7. Toggle control availability.

Add `_stop_recording()`:
1. Call `self._recorded_steps = self._recorder.stop()`.
2. Hide the recording indicator: `self._indicator.hide_indicator()`.
3. Toggle control availability.

Modify `_trigger_generate()` to include `baseline_state=self._baseline` and
`steps=self._recorded_steps` in the `BugReport` when they are non-empty.

Override `closeEvent()`:
```python
def closeEvent(self, event):
    if self._recorder.is_recording:
        self._stop_recording()
    self._indicator.hide_indicator()
    super().closeEvent(event)
```

### `pyprobe/gui/recording_indicator.py`

New file implementing `RecordingIndicator(QWidget)` as described above.

---

## Regression Guarantees

These 10 tests are **permanent**. All future milestones and future development must
pass them:

| Test | What It Guards |
|---|---|
| `test_recording_controls_toggle_state` | Start/Stop toggle correctly |
| `test_recording_mode_shows_indicator` | Indicator visible during recording |
| `test_recording_indicator_hidden_after_stop` | Indicator hidden after stop |
| `test_steps_section_absent_when_no_recording` | No phantom steps section |
| `test_generated_report_includes_steps_when_recorded` | Steps appear in output |
| `test_generated_report_includes_baseline_state` | Baseline state in output |
| `test_step_recorded_when_probe_action_fires` | Signal → step → report |
| `test_recording_stops_cleanly_if_dialog_closed` | No signal leak on close |
| `test_generate_after_stop_includes_all_steps` | All steps preserved |
| `test_second_recording_session_replaces_first` | Sessions are isolated |

---

## Non-Functional Constraints

- **Baseline captured at start time, not dialog open time.** `collect()` is called
  inside `_start_recording()`, not in `__init__`.
- **Steps cleared before each new session.** `_recorder.clear()` must be called at
  the beginning of `_start_recording()` before anything else.
- **No signal leak on dialog close.** `closeEvent()` must call `_stop_recording()`
  if the recorder is active. This triggers `stop()` which disconnects all signals.
- **Indicator is hidden on stop, not destroyed.** The indicator instance is reused
  across sessions; it is shown and hidden rather than created/destroyed each time.

---

## Completion Checklist

- [ ] M7 tests appended to `tests/gui/test_report_bug_dialog.py`; all 10 tests confirmed **failing** before implementation
- [ ] `pyprobe/gui/recording_indicator.py` implemented
- [ ] `pyprobe/gui/report_bug_dialog.py` updated (recording controls, baseline capture, signal hooks, `closeEvent`)
- [ ] Additional test helper methods added to `ReportBugDialog`
- [ ] All 10 new tests pass
- [ ] All 14 M5 tests still pass (no regressions in dialog MVP behavior)
- [ ] `python run_tests.py` fully green (all existing tests + M1–M6 tests still pass)
- [ ] No `# noqa` / `# type: ignore` without written justification
