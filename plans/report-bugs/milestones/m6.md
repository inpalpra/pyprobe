# Milestone 6 — StepRecorder

## Overview

This milestone implements `StepRecorder`, a pure-Python class that subscribes to
existing Qt signals and accumulates a chronologically ordered list of `RecordedStep`
objects. Recording has **zero measurable overhead when inactive** — calls to `record()`
on an inactive recorder are a single boolean check and immediate return.

`StepRecorder` is tested in isolation using minimal Qt signal objects. No `MainWindow`
or full application is required. Wiring into the dialog UI happens in M7.

---

## Guiding Principles

- **Tests first, implementation second.** Write all tests listed below, confirm every
  one is **failing**, then write the implementation that makes them pass.
- **Zero regression tolerance.** `python run_tests.py` must be fully green at the end
  of this milestone. No existing tests (including M1–M5's) may break.
- **Signal lifecycle correctness.** `stop()` must cleanly disconnect all signals
  connected via `connect_signal()`. Starting twice must not produce duplicate
  connections. These are tested explicitly.
- **Steps are a frozen snapshot after stop.** The `steps` property returns a `tuple`
  after `stop()` is called. Subsequent `record()` calls must not mutate it.
- **Two instances share no state.** `StepRecorder` is not a singleton.
- **Permanent regression suite.** Every test here is a permanent guard for all future
  milestones and future development.

---

## Goal

Implement `StepRecorder` with:

- `start()` / `stop()` / `clear()` lifecycle methods.
- `record(description: str)` — appends a `RecordedStep` only when active.
- `connect_signal(signal, description)` — connects a Qt signal so that each emission
  produces a recorded step; disconnects cleanly on `stop()`.
- `steps: tuple[RecordedStep, ...]` — the accumulated steps, frozen after `stop()`.
- `is_recording: bool` property.

---

## Dependencies

**Requires M2 (completed):**
- `pyprobe.report.report_model.RecordedStep` — the data type stored per step.

### RecordedStep Reference (restated for self-containment)

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class RecordedStep:
    seq_num: int       # 1-indexed, increments per recorded step
    description: str   # human-readable action description
    timestamp: float   # time.time() at the moment of recording
```

---

## New Files

```
pyprobe/report/step_recorder.py     create — write tests FIRST
tests/report/test_step_recorder.py  create — write tests FIRST
```

---

## Tests to Write First

All tests below **must be failing** before any implementation is written.
Tests that require Qt signals use `qtbot` from `pytest-qt`.

### `tests/report/test_step_recorder.py`

```python
import time
import pytest
from PyQt6.QtCore import QObject, pyqtSignal
from pyprobe.report.step_recorder import StepRecorder


# ── Minimal Qt signal emitter for testing ─────────────────────────────────────

class _Emitter(QObject):
    """Minimal QObject used to create real Qt signals in tests."""
    fired = pyqtSignal()
    fired_with_str = pyqtSignal(str)


# ── Lifecycle tests ───────────────────────────────────────────────────────────

def test_recorder_starts_inactive():
    """StepRecorder.is_recording is False immediately after construction."""
    recorder = StepRecorder()
    assert recorder.is_recording is False


def test_start_sets_is_recording_true():
    """After recorder.start(), is_recording is True."""
    recorder = StepRecorder()
    recorder.start()
    assert recorder.is_recording is True


def test_stop_sets_is_recording_false():
    """After start(); stop(), is_recording is False."""
    recorder = StepRecorder()
    recorder.start()
    recorder.stop()
    assert recorder.is_recording is False


# ── record() behaviour tests ──────────────────────────────────────────────────

def test_record_step_appends_when_active():
    """record('did X') appends a RecordedStep while recording is active."""
    recorder = StepRecorder()
    recorder.start()
    recorder.record("did X")
    assert len(recorder.steps) == 1
    assert recorder.steps[0].description == "did X"


def test_record_step_increments_seq_num():
    """Consecutive record() calls produce seq_num values 1, 2, 3, …"""
    recorder = StepRecorder()
    recorder.start()
    recorder.record("one")
    recorder.record("two")
    recorder.record("three")
    assert [s.seq_num for s in recorder.steps] == [1, 2, 3]


def test_record_step_has_timestamp():
    """RecordedStep.timestamp is close to time.time() at call time."""
    recorder = StepRecorder()
    recorder.start()
    before = time.time()
    recorder.record("now")
    after = time.time()
    assert before <= recorder.steps[0].timestamp <= after


def test_record_ignored_when_inactive_before_start():
    """record() before start() produces no steps."""
    recorder = StepRecorder()
    recorder.record("too early")
    assert len(recorder.steps) == 0


def test_record_ignored_after_stop():
    """record() after stop() does not append any steps."""
    recorder = StepRecorder()
    recorder.start()
    recorder.record("during")
    recorder.stop()
    recorder.record("after")
    assert len(recorder.steps) == 1
    assert recorder.steps[0].description == "during"


# ── clear() tests ─────────────────────────────────────────────────────────────

def test_clear_resets_steps_and_seq_num():
    """clear() empties steps and resets seq_num so the next record gets seq_num=1."""
    recorder = StepRecorder()
    recorder.start()
    recorder.record("a")
    recorder.record("b")
    recorder.clear()
    assert len(recorder.steps) == 0
    recorder.record("c")
    assert recorder.steps[0].seq_num == 1


# ── connect_signal() tests ────────────────────────────────────────────────────

def test_connect_signal_records_step_when_active(qtbot):
    """connect_signal(signal, 'did X') produces a step when the signal fires during recording."""
    emitter = _Emitter()
    recorder = StepRecorder()
    recorder.connect_signal(emitter.fired, "did X")
    recorder.start()
    emitter.fired.emit()
    assert len(recorder.steps) == 1
    assert recorder.steps[0].description == "did X"


def test_connect_signal_ignored_when_inactive(qtbot):
    """Signal firing before start() produces no steps."""
    emitter = _Emitter()
    recorder = StepRecorder()
    recorder.connect_signal(emitter.fired, "too early")
    emitter.fired.emit()
    assert len(recorder.steps) == 0


def test_connect_signal_with_formatter_callable(qtbot):
    """connect_signal(signal, fn) uses fn(*args) as the step description."""
    emitter = _Emitter()
    recorder = StepRecorder()
    recorder.connect_signal(emitter.fired_with_str, lambda s: f"received: {s}")
    recorder.start()
    emitter.fired_with_str.emit("hello")
    assert recorder.steps[0].description == "received: hello"


# ── Signal lifecycle tests (critical) ─────────────────────────────────────────

def test_stop_disconnects_signals(qtbot):
    """After stop(), signals that were connected no longer produce steps,
    even if those signals continue to fire."""
    emitter = _Emitter()
    recorder = StepRecorder()
    recorder.connect_signal(emitter.fired, "ping")
    recorder.start()
    emitter.fired.emit()
    assert len(recorder.steps) == 1

    recorder.stop()
    emitter.fired.emit()  # must not add to steps
    assert len(recorder.steps) == 1  # unchanged


def test_start_twice_does_not_duplicate_connections(qtbot):
    """Calling start() twice does not cause a single signal emission to record two steps."""
    emitter = _Emitter()
    recorder = StepRecorder()
    recorder.connect_signal(emitter.fired, "ping")
    recorder.start()
    recorder.start()  # second start — must not double-connect
    emitter.fired.emit()
    assert len(recorder.steps) == 1  # not 2


# ── Snapshot / isolation tests ────────────────────────────────────────────────

def test_steps_frozen_at_stop():
    """steps after stop() is a snapshot; subsequent record() calls have no effect."""
    recorder = StepRecorder()
    recorder.start()
    recorder.record("before stop")
    snapshot = recorder.stop()
    recorder.record("after stop")  # must not appear
    # The returned value from stop() (if any) and the steps property agree
    assert len(recorder.steps) == 1
    assert recorder.steps[0].description == "before stop"


def test_recorder_instances_are_independent():
    """Two StepRecorder instances share no state whatsoever."""
    r1 = StepRecorder()
    r2 = StepRecorder()
    r1.start()
    r1.record("r1 step")
    assert len(r2.steps) == 0


# ── Performance test ──────────────────────────────────────────────────────────

@pytest.mark.performance
def test_overhead_when_inactive_is_negligible():
    """Calling record() 10,000 times on an inactive recorder completes in under 20 ms.

    This guards against accidentally adding work to the hot-path of an inactive recorder.

    Marked @pytest.mark.performance — exclude in constrained CI with:
        pytest -m 'not performance'
    """
    recorder = StepRecorder()  # not started
    start = time.monotonic()
    for _ in range(10_000):
        recorder.record("ignored")
    elapsed = (time.monotonic() - start) * 1000  # ms
    assert elapsed < 20, f"Inactive recorder overhead: {elapsed:.1f}ms, expected < 20ms"
```

---

## Implementation Scope

### `pyprobe/report/step_recorder.py`

```python
from typing import Callable
import time

from pyprobe.report.report_model import RecordedStep


class StepRecorder:
    def __init__(self) -> None:
        self._is_recording: bool = False
        self._steps: list[RecordedStep] = []
        self._seq_num: int = 0
        self._connections: list[tuple] = []  # (signal, slot) pairs for cleanup

    @property
    def is_recording(self) -> bool: ...

    @property
    def steps(self) -> tuple[RecordedStep, ...]: ...

    def start(self) -> None: ...
    def stop(self) -> tuple[RecordedStep, ...]: ...
    def clear(self) -> None: ...

    def record(self, description: str) -> None:
        """Append a RecordedStep if currently recording. No-op otherwise."""
        if not self._is_recording:
            return   # ← critical: single boolean check, zero allocation
        ...

    def connect_signal(
        self,
        signal,
        description: str | Callable[..., str],
    ) -> None: ...
```

**`start()` implementation notes:**
- Set `_is_recording = True`.
- Guard against double-start: if already recording, do nothing (do not re-connect).

**`stop()` implementation notes:**
- Set `_is_recording = False`.
- Disconnect all stored `(signal, slot)` pairs by calling `signal.disconnect(slot)`.
- Clear `_connections`.
- Return `tuple(self._steps)` as a frozen snapshot.

**`connect_signal()` implementation notes:**
- Build a slot lambda that calls `self.record(description)` or
  `self.record(description(*args))` depending on whether `description` is callable.
- Call `signal.connect(slot)`.
- Append `(signal, slot)` to `_connections` for later disconnection on `stop()`.

**`record()` implementation notes:**
- The very first line must be `if not self._is_recording: return`.
  No work of any kind before this guard.
- Increment `_seq_num`, append `RecordedStep(seq_num=..., description=...,
  timestamp=time.time())` to `_steps`.

---

## Regression Guarantees

These 16 tests are **permanent**. All future milestones and future development must
pass them:

| Test | What It Guards |
|---|---|
| `test_recorder_starts_inactive` | Default state is inactive |
| `test_start_sets_is_recording_true` | `start()` activates recording |
| `test_stop_sets_is_recording_false` | `stop()` deactivates recording |
| `test_record_step_appends_when_active` | Steps accumulate during recording |
| `test_record_step_increments_seq_num` | Sequence numbers are monotonic |
| `test_record_step_has_timestamp` | Timestamp is real, not default |
| `test_record_ignored_when_inactive_before_start` | No steps before `start()` |
| `test_record_ignored_after_stop` | No steps after `stop()` |
| `test_clear_resets_steps_and_seq_num` | `clear()` fully resets state |
| `test_connect_signal_records_step_when_active` | Signal → step when active |
| `test_connect_signal_ignored_when_inactive` | Signal → no step when inactive |
| `test_connect_signal_with_formatter_callable` | Callable formatter applied |
| `test_stop_disconnects_signals` | Signals detached after `stop()` |
| `test_start_twice_does_not_duplicate_connections` | No double-connections |
| `test_steps_frozen_at_stop` | Snapshot immutable after `stop()` |
| `test_recorder_instances_are_independent` | No shared state between instances |
| `test_overhead_when_inactive_is_negligible` *(performance)* | < 20 ms for 10K no-ops |

---

## Non-Functional Constraints

- **Zero overhead when inactive.** The `record()` method's first statement must be
  `if not self._is_recording: return`. No allocation, no iteration, no signal check
  before this guard.
- **No Qt import at module load time.** `step_recorder.py` must not import from
  `PyQt6` at the module level. Signal types are accepted as untyped arguments
  (duck-typed). This keeps the module importable without a display.
- **Clean disconnect on stop.** Every `(signal, slot)` pair stored in `_connections`
  must be disconnected in `stop()`. Leaked connections cause silent duplicate
  recording bugs in subsequent recording sessions.
- **Not a singleton.** `StepRecorder` must have no class-level state. Two instances
  must never share steps or connection lists.

---

## Completion Checklist

- [ ] `tests/report/test_step_recorder.py` written; all 16 tests confirmed **failing** before implementation
- [ ] `pyprobe/report/step_recorder.py` implemented
- [ ] All 16 new tests pass (15 functional + 1 performance)
- [ ] `python run_tests.py` fully green (all existing tests + M1–M5 tests still pass)
- [ ] No `# noqa` / `# type: ignore` without written justification
