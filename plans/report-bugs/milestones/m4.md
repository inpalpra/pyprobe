# Milestone 4 — LogCapture

## Overview

This milestone implements `LogCapture`, which reads from PyProbe's log files on disk,
extracts the last N lines, classifies tracebacks and warning/error lines, and returns
structured data suitable for insertion into a `BugReport`. It is a standalone module
with no dependency on M3 (SessionStateCollector) or any GUI code.

M3 and M4 are independent of each other and may be developed in parallel after M2.

---

## Guiding Principles

- **Tests first, implementation second.** Write all tests listed below, confirm every
  one is **failing**, then write the implementation that makes them pass.
- **Zero regression tolerance.** `python run_tests.py` must be fully green at the end
  of this milestone. No existing tests (including M1–M3's) may break.
- **Never raise.** `LogCapture.capture()` must handle every failure mode gracefully:
  missing file, unreadable file, empty file. The caller must never receive an exception.
- **Always sanitize.** Every line of captured log text must pass through
  `PathSanitizer.sanitize()` before being stored.
- **Permanent regression suite.** Every test here is a permanent guard for all future
  milestones and future development.

---

## Goal

Implement `LogCapture.capture()`, which:

1. Reads the last N lines from a log file (default: 200 lines, default path:
   `/tmp/pyprobe_debug.log`).
2. Sanitizes all lines via `PathSanitizer`.
3. Extracts lines that begin a traceback block into `LogSnapshot.tracebacks`.
4. Extracts lines containing `WARNING` or `ERROR` into `LogSnapshot.warnings_and_errors`.
5. Returns a `LogSnapshot` dataclass, or `None` if the file cannot be read.

---

## Dependencies

**Requires M1 (completed):**
- `pyprobe.report.sanitizer.PathSanitizer` — applied to every captured log line.

M3 (SessionStateCollector) is **not required** by this milestone.

---

## New Files

```
pyprobe/report/log_capture.py     create — write tests FIRST
tests/report/test_log_capture.py  create — write tests FIRST
```

---

## Output Type Reference

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class LogSnapshot:
    raw_lines: str                   # All captured lines, joined as a single string
    tracebacks: tuple[str, ...]      # Traceback blocks extracted from captured lines
    warnings_and_errors: tuple[str, ...]  # WARNING / ERROR lines
```

---

## Tests to Write First

All tests below **must be failing** before any implementation is written.

### `tests/report/test_log_capture.py`

```python
import stat
import pytest
from pathlib import Path
from pyprobe.report.log_capture import LogCapture


# ── Fixtures ──────────────────────────────────────────────────────────────────

@pytest.fixture
def temp_log(tmp_path) -> Path:
    """Creates a temp log file populated with synthetic log lines."""
    log = tmp_path / "pyprobe_debug.log"
    lines = [
        "2026-01-01 00:00:01 INFO  Application started\n",
        "2026-01-01 00:00:02 DEBUG Tracer installed\n",
        "2026-01-01 00:00:03 WARNING unexpected None returned\n",
        "2026-01-01 00:00:04 ERROR Plot failed for eq0\n",
        "2026-01-01 00:00:05 INFO  Script ended\n",
        "Traceback (most recent call last):\n",
        '  File "/tmp/script.py", line 10, in run\n',
        "    raise ValueError('bad value')\n",
        "ValueError: bad value\n",
        "2026-01-01 00:00:06 INFO  Recovered\n",
    ]
    log.write_text("".join(lines))
    return log


# ── Line-count tests ──────────────────────────────────────────────────────────

def test_log_capture_returns_last_n_lines(temp_log):
    """capture(log_path, n=5) returns at most 5 lines in raw_lines."""
    snapshot = LogCapture.capture(log_path=str(temp_log), n=5)
    assert snapshot is not None
    assert len(snapshot.raw_lines.splitlines()) <= 5


def test_log_capture_returns_all_when_fewer_than_n(temp_log):
    """If the file has fewer lines than n, all lines are returned."""
    snapshot = LogCapture.capture(log_path=str(temp_log), n=1000)
    assert snapshot is not None
    assert len(snapshot.raw_lines.splitlines()) == 10  # fixture has 10 lines


# ── Edge case tests ───────────────────────────────────────────────────────────

def test_log_capture_empty_file_returns_snapshot_with_empty_content(tmp_path):
    """Empty log file returns a LogSnapshot with empty raw_lines, not None."""
    empty_log = tmp_path / "empty.log"
    empty_log.write_text("")
    snapshot = LogCapture.capture(log_path=str(empty_log))
    assert snapshot is not None
    assert snapshot.raw_lines == ""
    assert snapshot.tracebacks == ()
    assert snapshot.warnings_and_errors == ()


def test_log_capture_missing_file_returns_none():
    """Non-existent log path returns None without raising."""
    snapshot = LogCapture.capture(log_path="/nonexistent/path/pyprobe_debug.log")
    assert snapshot is None


def test_log_capture_does_not_raise_on_permission_error(tmp_path):
    """Unreadable file returns None gracefully; PermissionError is not propagated."""
    locked = tmp_path / "locked.log"
    locked.write_text("some content\n")
    locked.chmod(0o000)  # remove read permission
    try:
        snapshot = LogCapture.capture(log_path=str(locked))
        assert snapshot is None
    finally:
        locked.chmod(stat.S_IRUSR | stat.S_IWUSR)  # restore for cleanup


# ── Sanitization test ─────────────────────────────────────────────────────────

def test_log_capture_sanitizes_paths_in_log_lines(tmp_path):
    """Home paths embedded in log lines are replaced with <USER_HOME>."""
    home = str(Path.home())
    log = tmp_path / "sanitize.log"
    log.write_text(f"ERROR in {home}/repos/pyprobe/tracer.py at line 42\n")
    snapshot = LogCapture.capture(log_path=str(log))
    assert snapshot is not None
    assert home not in snapshot.raw_lines
    assert "<USER_HOME>" in snapshot.raw_lines


# ── Classification tests ──────────────────────────────────────────────────────

def test_log_capture_extracts_tracebacks(temp_log):
    """Lines beginning a traceback block appear in LogSnapshot.tracebacks."""
    snapshot = LogCapture.capture(log_path=str(temp_log))
    assert snapshot is not None
    assert len(snapshot.tracebacks) > 0
    assert any("Traceback" in tb for tb in snapshot.tracebacks)


def test_log_capture_extracts_warnings_and_errors(temp_log):
    """Lines with WARNING or ERROR appear in LogSnapshot.warnings_and_errors."""
    snapshot = LogCapture.capture(log_path=str(temp_log))
    assert snapshot is not None
    assert len(snapshot.warnings_and_errors) >= 2
    levels = " ".join(snapshot.warnings_and_errors)
    assert "WARNING" in levels or "ERROR" in levels
```

---

## Implementation Scope

### `pyprobe/report/log_capture.py`

```python
from dataclasses import dataclass

DEFAULT_LOG_PATH = "/tmp/pyprobe_debug.log"
DEFAULT_LINE_COUNT = 200


@dataclass(frozen=True)
class LogSnapshot:
    raw_lines: str
    tracebacks: tuple[str, ...]
    warnings_and_errors: tuple[str, ...]


class LogCapture:
    @classmethod
    def capture(
        cls,
        log_path: str | None = None,
        n: int = DEFAULT_LINE_COUNT,
    ) -> LogSnapshot | None:
        ...
```

Implementation notes:

1. **Read file.** Wrap the entire file read in `try/except Exception`; return `None`
   on any error (`FileNotFoundError`, `PermissionError`, `OSError`, etc.).
2. **Last N lines.** Use `collections.deque(maxlen=n)` for memory efficiency when
   reading large files.
3. **Sanitize.** Apply `PathSanitizer.sanitize()` to each line before any further
   processing.
4. **Extract tracebacks.** Scan lines for those starting with `"Traceback"` (after
   stripping leading whitespace). Collect the full traceback block (lines until the
   next non-indented, non-empty line after the exception message).
5. **Extract warnings/errors.** Collect lines containing the substrings `"WARNING"`
   or `"ERROR"` (case-sensitive, matching PyProbe's log format).
6. **Return `LogSnapshot`.** `raw_lines` is the last-N lines joined as a single string
   (preserving newlines). `tracebacks` and `warnings_and_errors` are `tuple[str, ...]`.

---

## Regression Guarantees

These 9 tests are **permanent**. All future milestones and future development must
pass them:

| Test | What It Guards |
|---|---|
| `test_log_capture_returns_last_n_lines` | Line limit respected |
| `test_log_capture_returns_all_when_fewer_than_n` | No truncation when under limit |
| `test_log_capture_empty_file_returns_snapshot_with_empty_content` | Empty file → empty snapshot |
| `test_log_capture_missing_file_returns_none` | Missing file → `None`, no exception |
| `test_log_capture_does_not_raise_on_permission_error` | Permission error → `None` |
| `test_log_capture_sanitizes_paths_in_log_lines` | All home paths sanitized |
| `test_log_capture_extracts_tracebacks` | Tracebacks correctly classified |
| `test_log_capture_extracts_warnings_and_errors` | Warning/error lines classified |

---

## Non-Functional Constraints

- **No Qt import.** `log_capture.py` must not import from `PyQt6` or `pyprobe.gui`.
- **Never raise to caller.** Every external failure (filesystem, permissions) must be
  caught internally and return `None` or an empty `LogSnapshot`.
- **Memory-efficient for large files.** Use `deque(maxlen=n)` or equivalent to avoid
  loading a multi-MB log file into memory entirely when only the tail is needed.

---

## Completion Checklist

- [ ] `tests/report/test_log_capture.py` written; all 9 tests confirmed **failing** before implementation
- [ ] `pyprobe/report/log_capture.py` implemented (`LogSnapshot`, `LogCapture.capture()`)
- [ ] All 9 new tests pass
- [ ] `python run_tests.py` fully green (all existing tests + M1–M3 tests still pass)
- [ ] No `# noqa` / `# type: ignore` without written justification
