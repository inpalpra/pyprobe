# Milestone 2 — Report Data Model & Plaintext Formatter

## Overview

This milestone defines the complete data model for a bug report as immutable Python
dataclasses, and implements `ReportFormatter`, which renders any `BugReport` to
structured plaintext. Both modules are pure Python with no Qt or GUI dependency.

All downstream milestones either produce `BugReport` instances or consume rendered
output. Getting the model and format contracts right here prevents churn in later work.

---

## Guiding Principles

- **Tests first, implementation second.** Write all tests listed below, confirm every
  one is **failing**, then write the implementation that makes them pass.
- **Zero regression tolerance.** `python run_tests.py` must be fully green at the end
  of this milestone. No existing tests (including M1's) may break.
- **Lock semantics, not cosmetics.** Formatter tests use golden-output checks
  (substring / key-presence assertions) rather than locking exact header phrasing
  or layout spacing. Cosmetic reformatting of the report is permitted in future
  milestones as long as all semantic tests still pass.
- **Immutability by construction.** All nested collection fields inside frozen
  dataclasses must use `tuple`, not `list`. Immutability must be testable and tested.
- **Automatic sanitization.** `ReportFormatter.render()` always applies
  `PathSanitizer.sanitize()` to its output regardless of caller intent.
- **Permanent regression suite.** Every test written here is a permanent guard for
  all future milestones and future development.

---

## Goal

Implement:

1. **Frozen dataclasses** representing every section of a bug report:
   `BugReport`, `OpenFileEntry`, `ProbeTraceEntry`, `EquationEntry`,
   `GraphWidgetEntry`, `RecordedStep`, `SessionState`.

2. **`ReportFormatter`** with `render(report: BugReport) -> str` that produces
   structured plaintext, automatically sanitizes all paths, and truncates oversized
   file contents with a warning.

---

## Dependencies

**Requires M1 (completed):**
- `pyprobe.report.sanitizer.PathSanitizer` — called inside `render()` to sanitize
  all output before it is returned.

---

## New Files

```
pyprobe/report/report_model.py     create — write tests FIRST
pyprobe/report/formatter.py        create — write tests FIRST
tests/report/test_report_model.py  create — write tests FIRST
tests/report/test_formatter.py     create — write tests FIRST
```

---

## Data Model Reference

These types are defined here and used by every later milestone. They are restated
in full so this file is self-contained.

```python
from dataclasses import dataclass, field

@dataclass(frozen=True)
class OpenFileEntry:
    path: str                       # Absolute path (sanitized on render)
    is_probed: bool
    is_executed: bool
    has_unsaved: bool
    contents: str | None = None     # Optional; opt-in by user

@dataclass(frozen=True)
class ProbeTraceEntry:
    name: str
    source_file: str                # Absolute path (sanitized on render)
    shape: tuple[int, ...]
    dtype: str

@dataclass(frozen=True)
class EquationEntry:
    eq_id: str
    expression: str
    status: str
    is_plotted: bool

@dataclass(frozen=True)
class GraphWidgetEntry:
    widget_id: str
    what_plotted: str
    is_docked: bool
    is_visible: bool

@dataclass(frozen=True)
class RecordedStep:
    seq_num: int
    description: str
    timestamp: float

@dataclass(frozen=True)
class SessionState:
    open_files:    tuple[OpenFileEntry, ...]       = ()
    probed_traces: tuple[ProbeTraceEntry, ...]     = ()
    equations:     tuple[EquationEntry, ...]       = ()
    graph_widgets: tuple[GraphWidgetEntry, ...]    = ()
    captured_at:   float                           = 0.0

@dataclass(frozen=True)
class BugReport:
    description:    str
    steps:          tuple[RecordedStep, ...] | None      = None
    baseline_state: SessionState | None                  = None
    open_files:     tuple[OpenFileEntry, ...] | None     = None
    environment:    dict | None                          = None
    logs:           str | None                           = None
```

**Note on `dict` in a frozen dataclass:** `environment` is a plain `dict`, which
is mutable. Treat it as read-only by convention; the constructor accepts it but must
never mutate it. A future milestone may convert it to a frozen type if needed.

---

## Tests to Write First

All tests below **must be failing** before any implementation is written.

### `tests/report/test_report_model.py`

```python
import pytest
from dataclasses import FrozenInstanceError
from pyprobe.report.report_model import (
    BugReport, OpenFileEntry, ProbeTraceEntry,
    EquationEntry, GraphWidgetEntry, RecordedStep, SessionState,
)


def test_bug_report_is_constructable_with_minimum_fields():
    """BugReport(description='X') works; all optional sections default to None."""
    report = BugReport(description="Something went wrong")
    assert report.description == "Something went wrong"
    assert report.steps is None
    assert report.baseline_state is None
    assert report.open_files is None
    assert report.environment is None
    assert report.logs is None


def test_open_file_entry_has_required_fields():
    """OpenFileEntry exposes path, is_probed, is_executed, has_unsaved, contents."""
    entry = OpenFileEntry(
        path="/tmp/script.py", is_probed=True, is_executed=True, has_unsaved=False
    )
    assert entry.path == "/tmp/script.py"
    assert entry.is_probed is True
    assert entry.contents is None  # default
    with_contents = OpenFileEntry(
        path="/tmp/script.py", is_probed=True, is_executed=True,
        has_unsaved=False, contents="x = 1\n",
    )
    assert with_contents.contents == "x = 1\n"


def test_probe_trace_entry_has_required_fields():
    """ProbeTraceEntry exposes name, source_file, shape, dtype."""
    entry = ProbeTraceEntry(
        name="signal_x", source_file="/tmp/script.py",
        shape=(1024,), dtype="float32",
    )
    assert entry.name == "signal_x"
    assert entry.shape == (1024,)


def test_equation_entry_has_required_fields():
    """EquationEntry exposes eq_id, expression, status, is_plotted."""
    entry = EquationEntry(
        eq_id="eq0", expression="np.power(tr0, 2)", status="ok", is_plotted=True
    )
    assert entry.eq_id == "eq0"
    assert entry.is_plotted is True


def test_graph_widget_entry_has_required_fields():
    """GraphWidgetEntry exposes widget_id, what_plotted, is_docked, is_visible."""
    entry = GraphWidgetEntry(
        widget_id="w0", what_plotted="eq0", is_docked=True, is_visible=True
    )
    assert entry.widget_id == "w0"


def test_recorded_step_has_required_fields():
    """RecordedStep exposes seq_num (int), description (str), timestamp (float)."""
    step = RecordedStep(seq_num=1, description="Clicked Run", timestamp=1_234_567_890.0)
    assert step.seq_num == 1
    assert isinstance(step.timestamp, float)


def test_bug_report_top_level_is_immutable():
    """Assigning to a BugReport field after construction raises FrozenInstanceError."""
    report = BugReport(description="test")
    with pytest.raises(FrozenInstanceError):
        report.description = "changed"  # type: ignore[misc]


def test_bug_report_internal_lists_are_immutable():
    """Nested collection fields are tuples; append() raises AttributeError or TypeError."""
    report = BugReport(
        description="test",
        open_files=(
            OpenFileEntry(
                path="/tmp/a.py", is_probed=False, is_executed=True, has_unsaved=False
            ),
        ),
    )
    with pytest.raises((AttributeError, TypeError)):
        report.open_files.append(  # type: ignore[attr-defined]
            OpenFileEntry(
                path="/tmp/b.py", is_probed=False, is_executed=False, has_unsaved=False
            )
        )
```

### `tests/report/test_formatter.py`

```python
import pytest
from pathlib import Path
from pyprobe.report.report_model import (
    BugReport, OpenFileEntry, RecordedStep,
)
from pyprobe.report.formatter import ReportFormatter


# ── Shared fixtures ───────────────────────────────────────────────────────────

@pytest.fixture
def formatter():
    return ReportFormatter()


@pytest.fixture
def minimal_report():
    return BugReport(description="Plot button did nothing.")


@pytest.fixture
def full_report():
    return BugReport(
        description="Equation re-plot failed after closing graph.",
        steps=(
            RecordedStep(seq_num=1, description="Clicked Plot for eq0", timestamp=1.0),
            RecordedStep(seq_num=2, description="Closed graph widget eq0", timestamp=2.0),
            RecordedStep(seq_num=3, description="Clicked Plot for eq0 again", timestamp=3.0),
        ),
        open_files=(
            OpenFileEntry(
                path="/tmp/dsp_demo.py",
                is_probed=True, is_executed=True, has_unsaved=False,
            ),
        ),
        environment={
            "pyprobe_version": "0.1.27",
            "python_version": "3.12.0",
            "platform": "darwin",
            "qt_version": "6.6.0",
            "plugins": ["scalar", "waveform"],
            "git_commit_hash": "abc1234",
        },
        logs="2026-01-01 INFO  Starting\n2026-01-01 ERROR Plot failed\n",
    )


# ── Golden output tests ───────────────────────────────────────────────────────

def test_render_minimal_report(formatter, minimal_report):
    """A BugReport with only a description produces non-empty output containing the description."""
    output = formatter.render(minimal_report)
    assert isinstance(output, str)
    assert len(output) > 0
    assert "Plot button did nothing." in output


def test_render_full_report(formatter, full_report):
    """A BugReport with all sections populated produces output containing key data from each."""
    output = formatter.render(full_report)
    assert "Equation re-plot failed" in output       # description
    assert "Clicked Plot for eq0" in output           # step
    assert "dsp_demo.py" in output                    # open file path
    assert "0.1.27" in output                         # environment value
    assert "Plot failed" in output                    # log line


def test_render_report_with_logs(formatter):
    """When logs is set, the rendered output contains those log lines verbatim."""
    report = BugReport(
        description="Check logs.",
        logs="WARNING: unexpected None\nERROR: tracer stopped\n",
    )
    output = formatter.render(report)
    assert "WARNING: unexpected None" in output
    assert "ERROR: tracer stopped" in output


def test_render_report_with_file_contents(formatter):
    """When OpenFileEntry.contents is set, the contents appear in the rendered output."""
    report = BugReport(
        description="File content test.",
        open_files=(
            OpenFileEntry(
                path="/tmp/script.py", is_probed=False, is_executed=True,
                has_unsaved=False, contents="import numpy as np\nx = np.zeros(1024)\n",
            ),
        ),
    )
    output = formatter.render(report)
    assert "import numpy as np" in output
    assert "x = np.zeros(1024)" in output


# ── Behavioral / conditional tests ───────────────────────────────────────────

def test_optional_section_omitted_when_none(formatter):
    """Sections corresponding to None fields produce no content in the output."""
    report = BugReport(description="Minimal.")
    output = formatter.render(report)
    # No step descriptions
    assert "Clicked" not in output
    # No environment version number pattern
    assert "0.1." not in output


def test_file_contents_omitted_when_entry_has_no_contents(formatter):
    """When OpenFileEntry.contents is None, no file content block appears."""
    report = BugReport(
        description="No contents.",
        open_files=(
            OpenFileEntry(
                path="/tmp/a.py", is_probed=False, is_executed=True,
                has_unsaved=False, contents=None,
            ),
        ),
    )
    output = formatter.render(report)
    assert "a.py" in output       # path still present
    assert "import" not in output  # but no content


def test_truncation_adds_warning_for_large_contents():
    """File contents exceeding max_file_bytes are truncated with a warning in the output."""
    large_content = "x = 1\n" * 100_000
    report = BugReport(
        description="Large file.",
        open_files=(
            OpenFileEntry(
                path="/tmp/big.py", is_probed=False, is_executed=True,
                has_unsaved=False, contents=large_content,
            ),
        ),
    )
    small_formatter = ReportFormatter(max_file_bytes=1024)
    output = small_formatter.render(report)
    assert len(output) < len(large_content)
    assert any(word in output.lower() for word in ("truncated", "truncation", "omitted", "bytes"))


def test_output_is_deterministic(formatter, full_report):
    """render(report) called twice on the same BugReport produces identical strings."""
    assert formatter.render(full_report) == formatter.render(full_report)


def test_paths_in_output_are_sanitized(formatter):
    """Home-directory paths injected into any field appear as <USER_HOME> in output."""
    home = str(Path.home())
    report = BugReport(
        description=f"File at {home}/repos/pyprobe crashed.",
        open_files=(
            OpenFileEntry(
                path=f"{home}/repos/pyprobe/script.py",
                is_probed=True, is_executed=True, has_unsaved=False,
            ),
        ),
        logs=f"ERROR in {home}/repos/pyprobe/tracer.py\n",
    )
    output = formatter.render(report)
    assert home not in output
    assert "<USER_HOME>" in output


def test_does_not_crash_on_empty_report(formatter):
    """BugReport with all optional fields None renders without raising."""
    report = BugReport(description="")
    output = formatter.render(report)
    assert isinstance(output, str)
```

---

## Implementation Scope

### `pyprobe/report/report_model.py`

- Define all frozen dataclasses from the Data Model Reference section.
- All nested collection fields (`open_files`, `probed_traces`, `equations`,
  `graph_widgets`, `steps`) must be typed as `tuple[..., ...]` and default to `()`.
  This ensures immutability is enforceable and testable without any additional logic.

### `pyprobe/report/formatter.py`

- `ReportFormatter(max_file_bytes: int = 50 * 1024)`.
- `render(report: BugReport) -> str`:
  - Assembles plaintext output.
  - Omits any section whose corresponding `BugReport` field is `None`.
  - Truncates `OpenFileEntry.contents` exceeding `max_file_bytes`; appends a
    truncation warning stating the original byte count.
  - Calls `PathSanitizer.sanitize()` on the final assembled string before returning.
- Section order and header wording are internal implementation details, not
  tested directly. The golden tests verify content presence only.

---

## Regression Guarantees

These 18 tests are **permanent**. All future milestones and future development must
pass them:

| Test | What It Guards |
|---|---|
| `test_bug_report_is_constructable_with_minimum_fields` | Minimal construction |
| `test_open_file_entry_has_required_fields` | OpenFileEntry field contract |
| `test_probe_trace_entry_has_required_fields` | ProbeTraceEntry field contract |
| `test_equation_entry_has_required_fields` | EquationEntry field contract |
| `test_graph_widget_entry_has_required_fields` | GraphWidgetEntry field contract |
| `test_recorded_step_has_required_fields` | RecordedStep field contract |
| `test_bug_report_top_level_is_immutable` | Top-level fields frozen |
| `test_bug_report_internal_lists_are_immutable` | Nested collections are tuples |
| `test_render_minimal_report` | Minimal report always renders |
| `test_render_full_report` | All sections present in full render |
| `test_render_report_with_logs` | Log lines appear verbatim |
| `test_render_report_with_file_contents` | File contents appear in output |
| `test_optional_section_omitted_when_none` | No phantom sections for None fields |
| `test_file_contents_omitted_when_entry_has_no_contents` | No phantom content blocks |
| `test_truncation_adds_warning_for_large_contents` | Truncation + warning enforced |
| `test_output_is_deterministic` | Render is stable across calls |
| `test_paths_in_output_are_sanitized` | No PII leaks from any field |
| `test_does_not_crash_on_empty_report` | Empty report never crashes |

---

## Non-Functional Constraints

- **No Qt import.** Neither `report_model.py` nor `formatter.py` may import anything
  from `pyprobe.gui` or `PyQt6`.
- **No filesystem I/O.** `render()` accepts a `BugReport` in memory and returns a
  string. No files are read or written.
- **Sanitization is unconditional.** `render()` must always call `PathSanitizer`
  as the final step, regardless of whether the caller sanitized anything earlier.

---

## Completion Checklist

- [ ] `tests/report/test_report_model.py` written; all 8 tests confirmed **failing** before implementation
- [ ] `tests/report/test_formatter.py` written; all 10 tests confirmed **failing** before implementation
- [ ] `pyprobe/report/report_model.py` implemented (frozen dataclasses, `tuple` fields)
- [ ] `pyprobe/report/formatter.py` implemented (`render()`, truncation, auto-sanitization)
- [ ] All 18 new tests pass
- [ ] `python run_tests.py` fully green (all existing tests + M1 tests still pass)
- [ ] No `# noqa` / `# type: ignore` without written justification
