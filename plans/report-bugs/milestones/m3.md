# Milestone 3 — SessionStateCollector

## Overview

This milestone implements `SessionStateCollector`, which builds a frozen `SessionState`
snapshot by calling injected getter callables. Because all GUI dependencies are provided
as constructor arguments (not imported directly), the collector is fully testable without
any Qt application running.

This milestone is placed before LogCapture (M4) because the `SessionState` snapshot is
required by the MVP dialog in M5. LogCapture (M4) is independent and can be developed
in parallel.

---

## Guiding Principles

- **Tests first, implementation second.** Write all tests listed below, confirm every
  one is **failing**, then write the implementation that makes them pass.
- **Zero regression tolerance.** `python run_tests.py` must be fully green at the end
  of this milestone. No existing tests (including M1–M2's) may break.
- **Getter injection.** All access to GUI objects is via `Callable[[], Iterable]`
  arguments injected at construction. Unit tests here use stubs only. The real wiring
  to `MainWindow` happens in M5.
- **Snapshot is a frozen copy.** Mutating the source data after `collect()` must never
  affect the returned `SessionState`. Nested collections are stored as `tuple`.
- **Errors in getters are swallowed.** A buggy or partially broken getter must never
  cause `collect()` to raise. The corresponding section returns an empty tuple instead.
- **Permanent regression suite.** Every test here is a permanent guard for all future
  milestones and future development.

---

## Goal

Implement `SessionStateCollector`, which:

1. Accepts four injectable getter callables at construction.
2. Calls each getter inside a `try/except` when `collect()` is invoked.
3. Converts all results to `tuple` and assembles a frozen `SessionState`.
4. Sanitizes all file paths via `PathSanitizer` before storing them.
5. Records `captured_at = time.time()` at the moment of collection.

---

## Dependencies

**Requires M1 (completed):**
- `pyprobe.report.sanitizer.PathSanitizer` — used to sanitize paths inside collected
  `OpenFileEntry` and `ProbeTraceEntry` objects.

**Requires M2 (completed):**
- The following types from `pyprobe.report.report_model`:
  `OpenFileEntry`, `ProbeTraceEntry`, `EquationEntry`, `GraphWidgetEntry`, `SessionState`.

### Data Types Consumed (restated for self-containment)

```python
@dataclass(frozen=True)
class OpenFileEntry:
    path: str           # sanitized before storage
    is_probed: bool
    is_executed: bool
    has_unsaved: bool
    contents: str | None = None

@dataclass(frozen=True)
class ProbeTraceEntry:
    name: str
    source_file: str    # sanitized before storage
    shape: tuple[int, ...]
    dtype: str

@dataclass(frozen=True)
class EquationEntry:
    eq_id: str
    expression: str
    status: str
    is_plotted: bool

@dataclass(frozen=True)
class GraphWidgetEntry:
    widget_id: str
    what_plotted: str
    is_docked: bool
    is_visible: bool

@dataclass(frozen=True)
class SessionState:
    open_files:    tuple[OpenFileEntry, ...]       = ()
    probed_traces: tuple[ProbeTraceEntry, ...]     = ()
    equations:     tuple[EquationEntry, ...]       = ()
    graph_widgets: tuple[GraphWidgetEntry, ...]    = ()
    captured_at:   float                           = 0.0
```

---

## New Files

```
pyprobe/report/session_snapshot.py     create — write tests FIRST
tests/report/test_session_snapshot.py  create — write tests FIRST
```

---

## Tests to Write First

All tests below **must be failing** before any implementation is written.

### `tests/report/test_session_snapshot.py`

```python
import time
import pytest
from pyprobe.report.report_model import (
    OpenFileEntry, ProbeTraceEntry, EquationEntry, GraphWidgetEntry
)
from pyprobe.report.session_snapshot import SessionStateCollector


# ── Helper ────────────────────────────────────────────────────────────────────

def make_collector(**overrides):
    """Return a SessionStateCollector with stub getters returning empty tuples.
    Pass keyword overrides to replace specific getters for individual tests.
    """
    defaults = dict(
        file_getter=lambda: (),
        probe_getter=lambda: (),
        equation_getter=lambda: (),
        widget_getter=lambda: (),
    )
    defaults.update(overrides)
    return SessionStateCollector(**defaults)


# ── Section content tests ─────────────────────────────────────────────────────

def test_snapshot_contains_open_files_from_getter():
    """Snapshot.open_files matches what file_getter returns."""
    entry = OpenFileEntry(
        path="/tmp/a.py", is_probed=True, is_executed=True, has_unsaved=False
    )
    collector = make_collector(file_getter=lambda: [entry])
    snapshot = collector.collect()
    assert len(snapshot.open_files) == 1
    assert snapshot.open_files[0].is_probed is True


def test_snapshot_contains_probed_traces_from_getter():
    """Snapshot.probed_traces matches what probe_getter returns."""
    entry = ProbeTraceEntry(
        name="sig", source_file="/tmp/a.py", shape=(512,), dtype="float32"
    )
    collector = make_collector(probe_getter=lambda: [entry])
    snapshot = collector.collect()
    assert len(snapshot.probed_traces) == 1
    assert snapshot.probed_traces[0].name == "sig"


def test_snapshot_contains_equations_from_getter():
    """Snapshot.equations matches what equation_getter returns."""
    entry = EquationEntry(
        eq_id="eq0", expression="np.power(tr0, 2)", status="ok", is_plotted=True
    )
    collector = make_collector(equation_getter=lambda: [entry])
    snapshot = collector.collect()
    assert len(snapshot.equations) == 1
    assert snapshot.equations[0].eq_id == "eq0"


def test_snapshot_contains_graph_widgets_from_getter():
    """Snapshot.graph_widgets matches what widget_getter returns."""
    entry = GraphWidgetEntry(
        widget_id="w0", what_plotted="eq0", is_docked=True, is_visible=True
    )
    collector = make_collector(widget_getter=lambda: [entry])
    snapshot = collector.collect()
    assert len(snapshot.graph_widgets) == 1
    assert snapshot.graph_widgets[0].widget_id == "w0"


# ── Timestamp test ────────────────────────────────────────────────────────────

def test_snapshot_records_capture_timestamp():
    """Snapshot.captured_at is close to time.time() at collection time."""
    before = time.time()
    snapshot = make_collector().collect()
    after = time.time()
    assert before <= snapshot.captured_at <= after


# ── Immutability tests ────────────────────────────────────────────────────────

def test_snapshot_is_immutable_after_capture():
    """Modifying the source list after collect() does not alter the snapshot."""
    source = [
        OpenFileEntry(
            path="/tmp/a.py", is_probed=False, is_executed=True, has_unsaved=False
        )
    ]
    collector = make_collector(file_getter=lambda: source)
    snapshot = collector.collect()
    source.append(
        OpenFileEntry(
            path="/tmp/b.py", is_probed=False, is_executed=False, has_unsaved=False
        )
    )
    assert len(snapshot.open_files) == 1  # snapshot unchanged


def test_baseline_state_is_snapshot_not_live_reference():
    """The snapshot holds a frozen copy. Mutating the original structure after
    collect() has no effect on any field of the snapshot."""
    inner = {"name": "sig", "source_file": "/tmp/a.py", "shape": (128,), "dtype": "f32"}
    entries = [
        ProbeTraceEntry(
            name=inner["name"], source_file=inner["source_file"],
            shape=inner["shape"], dtype=inner["dtype"],
        )
    ]
    collector = make_collector(probe_getter=lambda: entries)
    snapshot = collector.collect()
    # Clear the source list after collection
    entries.clear()
    # Snapshot must still contain the original entry
    assert len(snapshot.probed_traces) == 1
    assert snapshot.probed_traces[0].name == "sig"


# ── Robustness tests ──────────────────────────────────────────────────────────

def test_snapshot_does_not_raise_when_getter_returns_none():
    """If a getter returns None, the corresponding section is an empty tuple."""
    collector = make_collector(file_getter=lambda: None)
    snapshot = collector.collect()
    assert snapshot.open_files == ()


def test_snapshot_does_not_raise_when_getter_raises():
    """If a getter raises, the corresponding section is an empty tuple (no propagation)."""
    def broken():
        raise RuntimeError("GUI not ready")

    collector = make_collector(file_getter=broken)
    snapshot = collector.collect()  # must not raise
    assert snapshot.open_files == ()


# ── Path sanitization tests ───────────────────────────────────────────────────

def test_snapshot_paths_in_open_files_are_sanitized():
    """File paths in the snapshot have HOME replaced with <USER_HOME>."""
    from pathlib import Path
    home = str(Path.home())
    entry = OpenFileEntry(
        path=f"{home}/repos/script.py",
        is_probed=False, is_executed=True, has_unsaved=False,
    )
    snapshot = make_collector(file_getter=lambda: [entry]).collect()
    assert home not in snapshot.open_files[0].path
    assert "<USER_HOME>" in snapshot.open_files[0].path


def test_snapshot_paths_in_probe_sources_are_sanitized():
    """Probe source_file paths in the snapshot have HOME sanitized."""
    from pathlib import Path
    home = str(Path.home())
    entry = ProbeTraceEntry(
        name="sig", source_file=f"{home}/repos/script.py",
        shape=(64,), dtype="complex64",
    )
    snapshot = make_collector(probe_getter=lambda: [entry]).collect()
    assert home not in snapshot.probed_traces[0].source_file
    assert "<USER_HOME>" in snapshot.probed_traces[0].source_file


# ── Performance test ──────────────────────────────────────────────────────────

@pytest.mark.performance
def test_collect_is_fast_under_load():
    """collect() returns within 500 ms when getters return 1000 items each.

    Marked @pytest.mark.performance — exclude in constrained CI with:
        pytest -m 'not performance'
    """
    import time

    files = [
        OpenFileEntry(
            path=f"/tmp/file_{i}.py", is_probed=False, is_executed=True, has_unsaved=False
        )
        for i in range(1000)
    ]
    collector = make_collector(file_getter=lambda: files)

    start = time.monotonic()
    collector.collect()
    elapsed = time.monotonic() - start
    assert elapsed < 0.5, f"collect() took {elapsed:.3f}s, expected < 0.5s"
```

---

## Implementation Scope

### `pyprobe/report/session_snapshot.py`

```python
from typing import Callable, Iterable
import time

class SessionStateCollector:
    def __init__(
        self,
        file_getter:     Callable[[], Iterable] = lambda: (),
        probe_getter:    Callable[[], Iterable] = lambda: (),
        equation_getter: Callable[[], Iterable] = lambda: (),
        widget_getter:   Callable[[], Iterable] = lambda: (),
    ): ...

    def collect(self) -> SessionState: ...
```

`collect()` behaviour:

1. Call each getter inside a separate `try/except Exception`; on any failure, use `()`.
2. Sanitize path fields:
   - `OpenFileEntry.path` — replace with `PathSanitizer.sanitize(entry.path)`.
   - `ProbeTraceEntry.source_file` — replace with sanitized version.
   - Since dataclasses are frozen, create new instances with sanitized values.
3. Convert all results to `tuple`.
4. Return `SessionState(open_files=..., probed_traces=..., equations=...,
   graph_widgets=..., captured_at=time.time())`.

**Note on sanitizing frozen entries:** Because `OpenFileEntry` is frozen, path
sanitization requires constructing a new instance via `dataclasses.replace(entry, path=sanitized)`.

---

## Integration Note (M5)

In M5, `MainWindow._show_report_bug_dialog()` will construct a `SessionStateCollector`
by passing lambdas that delegate to live GUI objects:

```python
SessionStateCollector(
    file_getter=lambda: self._code_viewer.open_file_entries(),
    probe_getter=lambda: self._probe_controller.probe_trace_entries(),
    equation_getter=lambda: self._equation_manager.equation_entries(),
    widget_getter=lambda: self._probe_container.graph_widget_entries(),
)
```

Unit tests in this milestone use stubs only. GUI integration is tested in M5.

---

## Regression Guarantees

These 12 tests are **permanent**. All future milestones and future development must
pass them:

| Test | What It Guards |
|---|---|
| `test_snapshot_contains_open_files_from_getter` | File getter wired correctly |
| `test_snapshot_contains_probed_traces_from_getter` | Probe getter wired correctly |
| `test_snapshot_contains_equations_from_getter` | Equation getter wired correctly |
| `test_snapshot_contains_graph_widgets_from_getter` | Widget getter wired correctly |
| `test_snapshot_records_capture_timestamp` | Timestamp is real, not default |
| `test_snapshot_is_immutable_after_capture` | Source mutation after collect has no effect |
| `test_baseline_state_is_snapshot_not_live_reference` | Deep copy, not reference |
| `test_snapshot_does_not_raise_when_getter_returns_none` | None getter → empty tuple |
| `test_snapshot_does_not_raise_when_getter_raises` | Broken getter → empty tuple |
| `test_snapshot_paths_in_open_files_are_sanitized` | No PII in open file paths |
| `test_snapshot_paths_in_probe_sources_are_sanitized` | No PII in probe source paths |
| `test_collect_is_fast_under_load` *(performance)* | < 500 ms at 1000 items |

---

## Non-Functional Constraints

- **No Qt import.** `session_snapshot.py` must not import from `PyQt6` or `pyprobe.gui`.
  All GUI access is via the injected getters.
- **Frozen copy guarantee.** `collect()` must never return a reference to the getter's
  live data structure. All collections are converted to `tuple` before being stored in
  `SessionState`.
- **Exception isolation.** One broken getter must not prevent the other three from
  succeeding. Each getter is called in its own `try/except`.

---

## Completion Checklist

- [ ] `tests/report/test_session_snapshot.py` written; all 12 tests confirmed **failing** before implementation
- [ ] `pyprobe/report/session_snapshot.py` implemented
- [ ] All 12 new tests pass
- [ ] `python run_tests.py` fully green (all existing tests + M1–M2 tests still pass)
- [ ] No `# noqa` / `# type: ignore` without written justification
