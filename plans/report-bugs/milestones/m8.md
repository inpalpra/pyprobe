# Milestone 8 — Extended Output Options & PII Audit

## Overview

This final milestone adds three capabilities:

1. **Open GitHub Issue** — opens the user's browser with a pre-filled, correctly
   URL-encoded GitHub issue URL (title + body from the generated report).
2. **Deterministic JSON event log** — `ReportFormatter.render_json(report)` serializes
   all `BugReport` sections as structured JSON, suitable for developer tooling or LLM
   consumption.
3. **End-to-end PII audit** — a pipeline test that injects a home-directory path into
   every section of a `BugReport`, renders to both plaintext and JSON, and asserts that
   `str(Path.home())` appears in neither output. This is the permanent last line of
   defense against PII leakage.

Tests are added to existing files: `tests/report/test_formatter.py` (JSON tests) and
`tests/gui/test_report_bug_dialog.py` (GitHub URL + end-to-end PII test).

---

## Guiding Principles

- **Tests first, implementation second.** Write all tests listed below, confirm every
  one is **failing**, then write the implementation that makes them pass.
- **Zero regression tolerance.** `python run_tests.py` must be fully green at the end
  of this milestone. No existing tests (including M1–M7's) may break.
- **URL encoding is correct by construction.** Use `urllib.parse.urlencode` or
  `urllib.parse.quote` — never manual string concatenation for query parameters.
- **JSON sanitization is unconditional.** `render_json()` must apply `PathSanitizer`
  before returning, just as `render()` does.
- **Permanent regression suite.** Every test here is a permanent guard.

---

## Goal

Implement:

1. `ReportFormatter.render_json(report: BugReport) -> str` — deterministic, sanitized
   JSON serialization of a `BugReport`.
2. `ReportBugDialog` Open GitHub Issue action — builds a URL and calls `webbrowser.open()`.
3. End-to-end PII sanitization test.

---

## Dependencies

**Requires M5 (completed):** `ReportBugDialog` with Generate, Copy, Save actions.

**Requires M6 (completed):** `StepRecorder` (steps in the JSON output).

**Requires M7 (completed):** Recording mode integration (full `BugReport` with steps
and baseline state is now possible).

### ReportFormatter Reference (restated for self-containment)

```python
class ReportFormatter:
    def __init__(self, max_file_bytes: int = 50 * 1024): ...

    def render(self, report: BugReport) -> str:
        """Render BugReport to structured plaintext. Applies PathSanitizer."""

    def render_json(self, report: BugReport) -> str:
        """Render BugReport to deterministic JSON string. Applies PathSanitizer."""
```

### BugReport Reference (all fields)

```python
@dataclass(frozen=True)
class BugReport:
    description:    str
    steps:          tuple[RecordedStep, ...] | None      = None
    baseline_state: SessionState | None                  = None
    open_files:     tuple[OpenFileEntry, ...] | None     = None
    environment:    dict | None                          = None
    logs:           str | None                           = None
```

### GitHub Repository Constant

```python
# pyprobe/__init__.py
GITHUB_REPO_URL = "https://github.com/your-org/pyprobe"
```

The dialog constructs the issue URL as:
```
{GITHUB_REPO_URL}/issues/new?title={encoded_title}&body={encoded_body}
```

---

## New Files

None — all changes are additions to existing files.

## Modified Files

```
pyprobe/report/formatter.py              add render_json()
pyprobe/gui/report_bug_dialog.py         add Open GitHub Issue action
pyprobe/__init__.py                      add GITHUB_REPO_URL constant
tests/report/test_formatter.py           append JSON tests
tests/gui/test_report_bug_dialog.py      append GitHub URL + PII tests
```

---

## Tests to Write First

All tests below **must be failing** before any implementation is written.

### Additions to `tests/report/test_formatter.py`

```python
import json
from pathlib import Path
from pyprobe.report.report_model import BugReport, RecordedStep
from pyprobe.report.formatter import ReportFormatter


# ── JSON output tests ─────────────────────────────────────────────────────────

def test_render_json_is_valid_json():
    """render_json(report) returns a string that parses as valid JSON."""
    formatter = ReportFormatter()
    report = BugReport(description="JSON test.")
    output = formatter.render_json(report)
    parsed = json.loads(output)  # raises if invalid
    assert isinstance(parsed, dict)


def test_render_json_contains_steps():
    """JSON output includes a 'steps' key with seq_num, description, timestamp per entry."""
    formatter = ReportFormatter()
    report = BugReport(
        description="Steps test.",
        steps=(
            RecordedStep(seq_num=1, description="Clicked Run", timestamp=1_000_000.0),
            RecordedStep(seq_num=2, description="Closed widget", timestamp=1_000_001.0),
        ),
    )
    parsed = json.loads(formatter.render_json(report))
    assert "steps" in parsed
    assert len(parsed["steps"]) == 2
    step = parsed["steps"][0]
    assert "seq_num" in step
    assert "description" in step
    assert "timestamp" in step
    assert step["seq_num"] == 1
    assert step["description"] == "Clicked Run"


def test_render_json_contains_environment():
    """JSON output includes an 'environment' dict when environment is set."""
    formatter = ReportFormatter()
    report = BugReport(
        description="Env test.",
        environment={"pyprobe_version": "0.1.27", "platform": "darwin"},
    )
    parsed = json.loads(formatter.render_json(report))
    assert "environment" in parsed
    assert parsed["environment"]["pyprobe_version"] == "0.1.27"


def test_render_json_is_deterministic():
    """render_json(report) called twice on the same BugReport produces identical strings."""
    formatter = ReportFormatter()
    report = BugReport(
        description="Determinism test.",
        environment={"a": "1", "b": "2"},
    )
    assert formatter.render_json(report) == formatter.render_json(report)


def test_render_json_paths_are_sanitized():
    """No home-directory path appears anywhere in the JSON output."""
    home = str(Path.home())
    formatter = ReportFormatter()
    report = BugReport(
        description=f"Path at {home}/repos/pyprobe.",
        logs=f"ERROR in {home}/tracer.py",
    )
    output = formatter.render_json(report)
    assert home not in output
    assert "<USER_HOME>" in output
```

### Additions to `tests/gui/test_report_bug_dialog.py`

```python
import json
import urllib.parse
import webbrowser
from pathlib import Path
from unittest.mock import patch, MagicMock


# ── GitHub Issue action tests ─────────────────────────────────────────────────

def test_github_action_enabled_after_generate(qtbot):
    """Open GitHub Issue action becomes available after Generate is clicked."""
    dialog = make_dialog(qtbot)
    assert not dialog._github_action_enabled()
    dialog._trigger_generate()
    assert dialog._github_action_enabled()


def test_github_url_is_properly_url_encoded(qtbot):
    """The URL passed to webbrowser.open() has query params that are properly
    percent-encoded. Spaces become %20 or +; ampersands in content become %26."""
    dialog = make_dialog(qtbot)
    dialog._set_description("Problem with foo & bar")
    dialog._trigger_generate()

    with patch("webbrowser.open") as mock_open:
        dialog._trigger_open_github()
        assert mock_open.called
        url = mock_open.call_args[0][0]

    # URL must be parseable
    parsed = urllib.parse.urlparse(url)
    query = urllib.parse.parse_qs(parsed.query)
    assert "title" in query or "body" in query

    # The raw & must not appear unencoded in the query string portion
    raw_query = parsed.query
    # The description's literal & should be encoded, not raw
    # (parse_qs round-trip proves encoding was applied)
    assert "&" not in urllib.parse.unquote(raw_query).replace(
        urllib.parse.unquote(raw_query), ""
    ) or "foo & bar" in urllib.parse.unquote(raw_query)


def test_github_url_handles_special_characters(qtbot):
    """A description with newlines, quotes, and ampersands is encoded without
    breaking the URL structure (query string remains parseable)."""
    dialog = make_dialog(qtbot)
    dialog._set_description('Bug: "widget" fails\nwith x & y')
    dialog._trigger_generate()

    with patch("webbrowser.open") as mock_open:
        dialog._trigger_open_github()
        url = mock_open.call_args[0][0]

    # URL must be structurally valid — both parts present
    parsed = urllib.parse.urlparse(url)
    assert parsed.scheme in ("http", "https")
    assert parsed.netloc != ""
    # Query string must be parseable (no syntax errors from special chars)
    query_params = urllib.parse.parse_qs(parsed.query, keep_blank_values=True)
    assert len(query_params) > 0


def test_github_url_contains_no_home_path(qtbot):
    """The GitHub URL passed to webbrowser.open() contains no raw home-directory path."""
    from pyprobe.report.report_model import OpenFileEntry
    home = str(Path.home())
    collector = SessionStateCollector(
        file_getter=lambda: [
            OpenFileEntry(
                path=f"{home}/repos/pyprobe/examples/demo.py",
                is_probed=True, is_executed=True, has_unsaved=False,
            )
        ],
        probe_getter=lambda: (),
        equation_getter=lambda: (),
        widget_getter=lambda: (),
    )
    dialog = make_dialog(qtbot, collector=collector)
    dialog._trigger_generate()

    with patch("webbrowser.open") as mock_open:
        dialog._trigger_open_github()
        url = mock_open.call_args[0][0]

    # Decode any percent-encoding before checking for raw home path
    decoded_url = urllib.parse.unquote(url)
    assert home not in decoded_url


# ── End-to-end PII audit ──────────────────────────────────────────────────────

def test_path_sanitization_end_to_end(qtbot):
    """Full pipeline: inject a home-directory path into every section of a BugReport,
    render to both plaintext and JSON, assert str(Path.home()) appears in neither output.

    This is the final and permanent PII guard for the entire report pipeline.
    """
    from pyprobe.report.report_model import (
        BugReport, OpenFileEntry, ProbeTraceEntry, RecordedStep
    )
    from pyprobe.report.formatter import ReportFormatter

    home = str(Path.home())

    report = BugReport(
        description=f"Crash at {home}/repos/pyprobe/main.py",
        steps=(
            RecordedStep(
                seq_num=1,
                description=f"Loaded file {home}/examples/demo.py",
                timestamp=1.0,
            ),
        ),
        open_files=(
            OpenFileEntry(
                path=f"{home}/examples/demo.py",
                is_probed=True,
                is_executed=True,
                has_unsaved=False,
                contents=f"# Script at {home}/examples/demo.py\nimport numpy\n",
            ),
        ),
        environment={
            "pyprobe_version": "0.1.27",
            "virtualenv": f"{home}/.venv/bin/python",
        },
        logs=f"ERROR in {home}/repos/pyprobe/core/tracer.py at line 99\n",
    )

    formatter = ReportFormatter()

    plaintext = formatter.render(report)
    json_output = formatter.render_json(report)

    assert home not in plaintext, (
        f"HOME path leaked into plaintext report. Excerpt: "
        f"{plaintext[max(0, plaintext.find(home)-50):plaintext.find(home)+100]}"
    )
    assert home not in json_output, (
        f"HOME path leaked into JSON report."
    )

    # Positive check: sanitization marker must appear
    assert "<USER_HOME>" in plaintext
    assert "<USER_HOME>" in json_output
```

### Additional Test Helper Methods Required

These test helper methods must be added to `ReportBugDialog`:

| Method | Purpose |
|---|---|
| `_github_action_enabled() -> bool` | Returns whether the Open GitHub Issue action is available |
| `_trigger_open_github()` | Simulates activating the Open GitHub Issue action |

---

## Implementation Scope

### `pyprobe/report/formatter.py` — add `render_json()`

```python
def render_json(self, report: BugReport) -> str:
    """Render BugReport as a deterministic JSON string. Applies PathSanitizer."""
    ...
```

Requirements:
- Serialize all non-`None` fields of `BugReport` into a dict.
- `steps` — list of `{seq_num, description, timestamp}` dicts.
- `baseline_state` — dict with `open_files`, `probed_traces`, `equations`,
  `graph_widgets`, `captured_at`.
- `open_files` — list of `{path, is_probed, is_executed, has_unsaved}` dicts
  (contents omitted from JSON to keep it concise; include if set).
- `environment` — the dict as-is.
- `logs` — the string as-is.
- Serialize with `json.dumps(data, indent=2, sort_keys=True)` to ensure
  determinism across Python versions.
- Apply `PathSanitizer.sanitize()` to the final JSON string before returning.

### `pyprobe/__init__.py` — add `GITHUB_REPO_URL`

```python
GITHUB_REPO_URL = "https://github.com/your-org/pyprobe"
```

Replace `your-org` with the actual repository owner when known.

### `pyprobe/gui/report_bug_dialog.py` — add GitHub action

Add "Open GitHub Issue" output action (disabled until Generate is clicked).

`_trigger_open_github()`:
1. Extract the user description as the issue title (truncated to 100 chars if needed).
2. Use the full generated report text as the issue body.
3. Build URL:
   ```python
   import urllib.parse
   import webbrowser
   import pyprobe

   params = urllib.parse.urlencode({
       "title": title,
       "body": body,
   })
   url = f"{pyprobe.GITHUB_REPO_URL}/issues/new?{params}"
   webbrowser.open(url)
   ```
4. **Must use `urllib.parse.urlencode`** — never manual string concatenation for
   query parameters. This is the only correct way to handle special characters.

---

## Regression Guarantees

These 10 tests are **permanent**. All future milestones and future development must
pass them:

| Test | What It Guards |
|---|---|
| `test_render_json_is_valid_json` | JSON output always parseable |
| `test_render_json_contains_steps` | Steps serialized correctly |
| `test_render_json_contains_environment` | Environment dict in JSON |
| `test_render_json_is_deterministic` | JSON output stable across calls |
| `test_render_json_paths_are_sanitized` | No PII in JSON output |
| `test_github_action_enabled_after_generate` | GitHub action gated on Generate |
| `test_github_url_is_properly_url_encoded` | URL encoding correct |
| `test_github_url_handles_special_characters` | Special chars do not break URL |
| `test_github_url_contains_no_home_path` | No PII in GitHub URL |
| `test_path_sanitization_end_to_end` | **No PII in any output from any field** |

The final test (`test_path_sanitization_end_to_end`) is the permanent last line of
defense for the entire report pipeline. It must always pass.

---

## Non-Functional Constraints

- **`render_json()` is deterministic.** `json.dumps(..., sort_keys=True)` ensures
  dict key order is stable across Python versions and runs.
- **URL encoding uses stdlib only.** `urllib.parse.urlencode` is the only acceptable
  approach. No third-party URL builders.
- **Sanitization is unconditional in `render_json()`.** `PathSanitizer.sanitize()` is
  called on the final JSON string regardless of whether individual fields were sanitized
  earlier in the pipeline.

---

## Full Regression Test Count (All Milestones)

At the completion of M8, the total new regression test suite covers:

| File | Tests | Guarantees |
|---|---|---|
| `tests/report/test_sanitizer.py` | 8 | Path sanitization correctness |
| `tests/report/test_environment.py` | 8 | Env collection: valid, sanitized, fast* |
| `tests/report/test_report_model.py` | 8 | Data model: immutable, correct fields |
| `tests/report/test_formatter.py` | 10 + 5 | Plaintext + JSON format; no PII |
| `tests/report/test_session_snapshot.py` | 12 | Snapshot: no raise, frozen copy, sanitized |
| `tests/report/test_log_capture.py` | 9 | Log capture: no raise, sanitized, limited |
| `tests/report/test_step_recorder.py` | 16 | Signal lifecycle; zero overhead when inactive* |
| `tests/gui/test_report_bug_dialog.py` | 14 + 10 + 4 | Dialog flow; recording; GitHub; PII audit |
| **Total** | **~96** | All permanent |

_\* Performance-marked tests, excluded with `-m 'not performance'` in constrained CI._

---

## Completion Checklist

- [ ] M8 tests appended to `tests/report/test_formatter.py`; all 5 tests confirmed **failing** before implementation
- [ ] M8 tests appended to `tests/gui/test_report_bug_dialog.py`; all 5 tests confirmed **failing** before implementation
- [ ] `pyprobe/report/formatter.py` updated with `render_json()` (`sort_keys=True`, sanitized)
- [ ] `pyprobe/__init__.py` updated with `GITHUB_REPO_URL`
- [ ] `pyprobe/gui/report_bug_dialog.py` updated with Open GitHub Issue action and helper methods
- [ ] All 10 new tests pass
- [ ] All prior milestone tests still pass (M1–M7, no regressions)
- [ ] `python run_tests.py` fully green
- [ ] No `# noqa` / `# type: ignore` without written justification
